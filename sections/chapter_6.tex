\chapter{Architecting a Multi-tenant System}

Architecting of any software or system faces some concerns and challenges; this is also true for multi-tenancy. Although many of the challenges encountered during multi-tenant architecting is similar to that encountered in single-tenant application architecting, the challenges are often presented in another form or complexity level for multi-tenant approaches \cite{Bezemer:2010:MSA:1862372.1862393}. This chapter takes a look at the concerns and challenges faced when architecting a multi-tenant system and attempts to support the ultimately chosen solutions to these.


\section{Performance}
\subsection{Performance Isolation}

It is common for single-tenant applications to have one instance consume all available resources. In such a case one tenant's behaviour does not affect another. However, this is not the case for multi-tenant applications where resources are shared and the over-utilization by one tenant does directly impact another. Tenant performance isolation aims to reduce the performance impact between tenants through using fairness policies, throttling techniques or specific design patterns. Since multi-tenant applications aim to be elastically scalable, tenant performance isolation should be designed to support a scaling model and not restrict tenants. This means assigning equal amounts of resources between tenants is not an effective solution as it leads to low utilization of resources since one tenant might require a lot of resources while another might be using almost nothing \cite{Bezemer:2010:MSA:1862372.1862393}. In order to improve performance isolation in our architecture a Queue Centric Workflow pattern (see section \ref{sec:qcw} ) \cite{Wilder2012-so} is used.

\section{Caching}

In single-tenant applications the use of in memory caching is a quick and easy solution to performance improvement. However, using in memory caching in a multi-tenant environment is not viable, since cached data might need to be shared across multiple application instances. In order to address this, an external cache provider has to be used for maintaining cache data for all application instances. Azure Redis Cache has been implemented in the prototype as cache provider using the Cache Aside pattern \cite{Swanson}. Using an external cache instead of in memory caching does introduce some latency as a network component is introduced. As long as the application and its external cache are hosted within the same datacenter however, this latency can be kept to an acceptable minimum.


\section{Scalability}


\subsection{Auto-scaling}

Auto-scaling is the capability of dynamically allocating more or less resources as required by an application on demand and in accordance to some predefined Service Level Agreement (SLA) \cite{Swanson}. Cloud -Native applications strive to be completely auto-scalable which allows large savings due to the over provisioning of resources. Auto-scalable applications can demand more resources be provisioned when loads are high and could allow resources to be removed when it detects that allocated resources are not being completely utilized. Although implementing a fully auto -scalable application for this thesis would be ideal, as it stands it has been deemed out of scope. However, since it is hard to change a horizontally scalable application to a completely auto-scalable one some architectural decisions were made with auto-scaling in mind such as application statelessness and affinity.


\subsection{Affinity and State}

In order to improve the performance and scalability of the multi-tenant application, a stateless Web Tier is used. This means that the application requires no affinity since as no specific application instance will store session state data and therefore any instance can handle all application requests. This in effect allows us to scale horizontally without having to worry about maintaining affinity for our users. In cases where some session information has to be stored a client side mechanism is suggested instead. A common client side method is storing specific session data in a cookie using JavaScript Object Notation (JSON). In cases where storing sensitive information on the client side encryption should be used. When user authentication states are stored in cookies it is also important to remember that attackers that capture the cookie will be able to impersonate that user and therefore protection mechanisms should be put in place e.g. cross site scripting guards.


\subsection{Multi-Instance Model}

One major drawback introduced by migrating to a multi-tenant approach is the creation of a single point of failure. That is, that once the instance of the application goes down or is affected by some externality, all tenants are affected and are unable to access the application. If this was to occur it could be potentially devastating for any service oriented company tied to a SLA. Therefore, some contingency for such a situation is critical to consider, even during the design phase.
 
One possible solution to help mitigate this risk is using a multi-tenant, multi-identical-instance model instead. That means that the exact same application and roles are replicated to different virtual machines or physical locations. A load balancer is then used to balance the load between these two identical instances. In the event that something would happen to one of these instances, the load balancer would then easily be able to switch all requests to the other instance and therefore ensure availability of the application.


\section{Security}


\subsection{Multi-facet Authentication}

User authentication in a multi-tenant system requires additional security measures. Firstly, users need to be authenticated in order to ensure that they are allowed to access the application. Once a user has been authenticated against the service, it needs to be authenticated against the tenant it is claiming to belong to. Only once a tenant has been authenticated to both use the system and access a specific tenant's data is it allowed to be fully authenticated. Furthermore, user requests also need to be checked to ensure they are allowed to be executed against the requested tenant. This forms part of tenant data isolation.


\subsection{Tenant Data Isolation}

One of the primary risk factors introduced by multi-tenancy is that of cross tenant data leakage. An example of this is a case where a CRUD command of one tenant affects or retrieves the information of another tenant. For any application this is behaviour would be unacceptable. It is therefore that proper tenant data isolation is considered one of the essential security factors that needs to be addressed by the systems architect \cite{Wilder2012-so}. By using multi-facet authentication queries can be analyzed and adapted in order to ensure that they only retrieve information connected to the requested tenant and by an authorized customer.


\section{Availability}

In order to control the physical hosting location for your services, Azure requires you to bind your services to a specific region. This region corresponds to the (currently 11) available Azure Data Centres around the world\cite{Microsoft_Corporation2014-bf}. Thus specifying which region should host your services is equal to selecting the actual data centre where your services will be physically hosted. However, within the data centre it might be beneficial to co-locate services in close physical proximity to each other in order to reduce latency, up performance and cut costs \cite{Microsoft_Corporation2014-dn}.
 
This is where affinity groups come into play. These groups are defined at subscription level and helps Azure to know to group services that belong to a specific affinity group in close physical proximity. Affinity groups are tied to regions.
 
It is important to note that with recent changes in Azure Virtual Network structures that the VNets are no longer tied to affinity groups, but directly associated with the regions. This means that when you create your VNet and affinity group, they should both be located in the same region \cite{Microsoft_Corporation2014-dn}.


\section{Configuration and Customization}

The degree to which individual customers are able to customize anything from layouts to schemas should be carefully considered during the application design stages in order to ensure that the architecture allows for sufficient customization from the start. Krebs states that the ability to handle different tenant specific configurations regarding the User Interface (UI) as well as other functional or non -functional behaviour is can be considered as key enabler for multi-tenant applications \cite{Krebs2012}. Since tenants will require some changes or modifications such as extended features, implementation of these features should not influence other parts of the system.
 
The customization required by the multi-tenant application proves to be one of the core elements driving many of the design choices. Since each tenant requires complete customization of the front-end to fit their respective business identity (BI) as well as lower level extension to the system such as publisher filtering on database level, where specific publishers should only be shown to specific tenants, and some to all. Other important customization considerations include workflow processes used by different clients and how workflows would be implemented to include possible changes by the client.


\subsection{Tenant Customization}

In many multi-tenant systems the difference between tenants is minor and can usually be handled by storing the differences in configuration. Settings such as corporate identity (CI) which includes fonts, colours and logos or even which parts of the service that has been enabled or disabled is retrieved from the external configuration and applied. However, in our system, this level of configuration is not enough. The XVA requires high levels of modification for the front-end for each tenant. Although the development of highly configurable software is not commonly the responsibility of the multi-tenant application \cite{Krebs2012}, the specific of implementing such an application has been considered during the architecture design. As such, custom views are a robust solution for implementing tenant specific customizations. Custom views effectively allow us to create different views for each tenant, customizing the HTML and CSS for that view to the tenant's requirements. It also allows us to create a custom master or layout view that can be used to apply the tenants CI. This solution could also allow us to use shared views for situations where tenant specific customization is not required. In order for our custom view solution to be applied in ASP.NET MVC, we create a custom view engine. View engines are primarily responsible for rendering the code from your views into HTML that is served by the browser.

However, View Engines are also capable of defining search paths and retrieving specific views to be served. It is these capabilities that are used to allow our application to search for, and retrieve tenant specific views. Since our requirement does not include any customization to the way views are rendered, extending an existing view engine such as Razor is the most viable option. Morris \cite{Morris} provides a good example implementation of such an extended Razor view engine that allows for multi-tenancy. His approach is implemented in the prototype. A major drawback of using custom views is it removes our ability to dynamically provision new customized tenants. If the tenant's configuration is stored separately from the system following the external configuration store pattern \cite{Swanson}, new tenants can be provisioned dynamically without any modified views. However, since adding views to a project requires the project to be rebuilt, a new deployment will have to be made when custom views are added. For our case however the high customizability provided by custom views outweighs the drawback of having to constantly redeploy. In order to ease the influence of constant redeployments, using of a continuous integration workflow is strongly suggested.


\section{Maintenance}

Bezemer \& Zaidman \cite{Bezemer:2010:MSA:1862372.1862393} state that using multi-tenancy could result in a maintenance dream since application deployment is significantly simplified. By using a single instance of the application and database, any changes simply need to be deployed once. However, this simplified maintenance is closely coupled with implementation quality. High quality multi-tenant application utilize a layered architecture that has multi-tenancy applied as a cross cutting concern \cite{Bezemer:2010:MSA:1862372.1862393}.


\subsection{Provisioning}

Since adding tenant specific views requires redeployment, provisioning of new tenants with their custom views in our system will not be an automated process. Tenants can however be created dynamically as tenant data is stored externally. This means new tenants can be provisioned without a redeploy, but will only have the generic shared or default views set. In order to properly provision a new custom tenant however, the tenant's specific views can firstly be created, a deployment done and once the tenant needs to be activated it can be created dynamically by an application manager. Once the tenants data has been stored, the application will then be able to automatically associate the custom views with that tenant and start serving the tenant specific customized views. This provisioning process works for our specific case study since a new tenant is usually slowly introduced and requires such high levels of view customization. Multi-tenant systems that have large numbers of tenants (10+) should however rather consider moving away from custom views into a more generic configuration based customization approach, especially where tenant provisioning should be completely dynamic and automated. One method helping to reduce the impact of redeployment for tenant provisioning is by using a build server such as TeamCity combined with a continuous deployment, integration and delivery strategy.


\section{Persistence Design}

In multi-tenant system design many different approaches to designing a persistence model can be taken including \cite{Krebs2012}:

\begin{itemize}
\item Dedicated database: Each tenant has their own specific database. This approach offers the highest level of tenant isolation but is considered the least effective multi-tenant approach since it does not attempt to share resources. Allows the high levels of schema customization per tenant.
\item Dedicated table/schema: Tenants share a single database but have their own dedicated tables within that database. This approach is considered better at resource sharing but still does not allow high enough levels of resource sharing. Cross tenant queries for reporting purposes are also harder to implement with this approach. Furthermore, allows high degrees of schema customization.
\item Shared table/schema: All tenants share a single schema or table and provide means for schema extension through extension columns. This approach is considered the purest multi-tenant approach but implores restrictions on schema modification.
\end{itemize}


Since our application requires a constantly varying schema using a schema-less database has been chosen. This allows us to obtain the highest degree of flexibility. In order to allow the most effective persistence design to be implemented a shared database, dedicated collection approach was taken. This approach is similar to the dedicated table/schema approach in the sense that a single database is used by all tenants but each tenant has their own respective collection (groupings of documents, searchable indexes, entities etc.).Furthermore since a single data storage type does not fit all our specific needs such as auto-indexing of fields for searchable items and easy persistence of JSON objects as query-able documents a polyglot persistence model is used.


\subsection{Polyglot Persistence Model}

The term polyglot persistence is used to refer to the utilization of different data stores and types in order to store data \cite{Sadalage2012-zw}. This means that systems information is stored in various different databases with different schemas and models in order to be used for their intended purpose and by providing the required benefits for that specific data storage type. For this thesis a polyglot persistence approach is taken by storing specific data into different databases and different database types. Media items that should be searchable quickly queried and should have powerful search and filtering features such as geosearch are stored in Azure Search (Database). This allows all media items to use an easily modifiable schema (at code level), while providing full text search and fully indexed objects for quick and constant queries. The marketplace data is stored in Azure Document DB since the document storage is fast and easy to use. It allows more complex querying compared to key-value store typed storage and allows us to persist objects directly into the database without the need to use an ORM mapper. Finally for identity information, traditional Azure SQL is used since these work well with existing identity providers and have been optimized to work out of the box such as Open Web Interface for.NET (OWIN). Stateful data such as a user's shopping cart or selected media items is stored using Azure Cache. This specific separation of persistence allows us to gain the benefits of each of the respective persistence technologies at the cost of introducing higher code complexity.


\section{Accessibility}

One of the most common ways to distinguish between tenants is using the tenant name as area and mapping the tenant name as an area using MVC routing. However XV tenants wish to maintain their own Domain Name System (DNS) name and access to the system should therefore be setup using sub domains. A suggested method for doing this is setting up a Canonical Name Record (CNAME) entry with our DNS provider that points all domains via the "*" wildcard to the application instance. This will allow us to have tenants to set up their DNS to point to <tenant-name>.<our-domain>.


