\chapter{Prototype Artefact - XVP}

In order to measure the viability of the produced architecture description artefact a prototype artefact has been created. This artefact, codenamed XV Prototype (XVP) is used in order to gain valuable implementation insights into the development of an actual working multi-tenant application. It also helps reflect on architectural decisions made and provides useful feedback for improvement of the architecture development for future production implementations.

\section{Application Source Code}

The source code for our prototype has been hosted on BitBucket and is accessible from \textbf{https://bitbucket.org/auronmatrix\_/xvp}. Please note that the repository is private as the source code contains some sensitive and private information. \textbf{To obtain access to this repository please send your requests to 417457@mail.muni.cz}

\section{Accessing the Prototype}
For this project the domain fithesis.info was registered and an a CNAME (Alias) entry was added to the DNS Zone File to point all hosts (*) to our azure instance (xvp.azurewebsites.net). This allows us to dynamically add any tenants with their own custom domain name in the form
<custom-subdomain>.fithesis.info. 

Two core tenants have been setup:
\begin{itemize}
\item ao.fithesis.info (default) : Primary tenant, representing the XV site with full functionality
\item xv.fithesis.info (custom tenant) : Secondary tenant with custom layout, views and workflows
\end{itemize}

\section{Tenant Provisioning}
When a new tenant is created without a redeployment with customized views the view engine will automatically access the shared default views and use them. Once custom views have however been created and a redeployment done the view engine will retrieve these custom views in priority order:
\begin{enumerate}
\item tenant-<tenant-name>/controller
\item tenant-<tenant-name>/shared
\item global/controller
\item global/shared
\end{enumerate}

\section{Limitations and Issues}
\subsection{Azure Pricing}
In contrast to implementing the prototype on Windows Azure Web Roles and using Azure Worker Role instances, it was decided to implement the prototype using Azure Websites and Azure WebJobs instead. In Appendix \ref{appendix} these technologies and their respective advantages disadvantages are discussed. This problem is considered low impact since it does not alter a lot of code. However, the physical performance of this choice is noticeable.

\subsection{Domain Driven Design}
CQRS is commonly implemented as pattern in conjunction with domain driven design \cite{Swanson}. This leads to a radical change in the way domain objects are created and the way they act. It also requires using of aggregates for accessing related entities. Fundamentally, completely implementing domain driven design would be ideal since it would give us the many of the domain driven design benefits. As such it is recommended for any further implementations of a system based on the prototype to use domain driven design as its principal design approach. However, in order to simplify the design, creation and implementation processes, domain driven design has not been implemented in the prototype. Also since existing team members are not completely familiar with DDD and its specifications from a business perspective this choice made sense. In order for the application to be easily migrated to a DDD approach the DDD application layers have been used in the prototype implementation already. This plus CQRS and the Command pattern allows us to easily switch to a DDD approach by removing the generic command objects and replacing them with domain specific commands.

\subsection{WebJob Polling Service}
An Azure WebJob application is used to consume and execute commands placed in the Azure Storage Queue. The WebJob works very efficiently for processes that require long running asynchronous background processing. Since we implement CQRS and the majority of commands in the storage queue is related to data persistence operations (insert, update, delete) which although not time critical, is time sensitive. With the Azure WebJobs setup the WebJobs only polls the storage queues once every 10 minutes by default. This value has been changed to under 10 seconds however a small delay in time the command is queued and time the command is executed can still be observed. The easiest solution to this problem would require moving out of the Azure Websites as WebJob and into their own respective Azure Worker Role instance. This would significantly improve the performance of the queue handler as Worker Roles run as their own application instances with dedicated memory, where WebJobs run within an Azure Website with shared memory. This would also allow us better flexibility in the configuration of the application environment and would allow us to optimize the instance for processing messages from the storage queue.

\subsection{Azure Document Db Preview Release Limits}
At time of writing Azure Document DB has only been released for Public Preview. Specific limitations that severely affected the prototype development and method for implementing multi-tenancy was its container limitations \cite{AzureLimits}. Each DocumentDB only allows the creation of 3 collections that act as containers for documents. This proved to be a problem since a collection per tenant approach for specific information and a shared container approach for others was used by our architecture description. In order to solve the container problem, database level separation (as opposed to container) level separation was implemented. However this introduces severe limitations on cross tenant querying capabilities and should not be followed in the production implementation.

\section{Conclusion}

